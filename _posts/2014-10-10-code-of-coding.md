---
layout: post
tags: c++ 
categories: code

---

Programming is a process of decision making. There are many ways to make thing work, but most of them are bad ways. The code of coding helps to define good from bad.

The following rules are my own understanding for ZJUCVG daily research coding, in which case Visual Studio on Windows is the main environment. Some of them may not apply to other circumstances. But remember the key idea is to make things easier, not only for now, but also for the future(flexibility).

I borrow some of the rules from [Google C++ Style Guide](http://google-styleguide.googlecode.com/svn/trunk/cppguide.html), but I can agree no more than 2/3 of them.
More over, rather than make forcible rules, I would like to trust people. Rules should be a reference for peer-review. Just like the Jury System in a Common Law country.

## 1. Header

Differences between .h and .cpp

<table width = "100%">
<tbody>
<tr><td> .h </td><td> .cpp </td> </tr>
<tr>
<td>
What can I do?<br>
</td>
<td>
How to do it?<br>
</td>
</tr>
<tr>
<td>
Precompile (Expanded to text.)
</td>
<td>
Compile (to Binary, .obj in VC.)
</td>
</tr>
<tr>
<td>
Affect all files include it. <br>
Be more careful.<br>
</td>
<td>
Local.
</td>
</tr>
</tbody>
</table>

### 1.1 #pragma once
To prevent multiple inclusion.

<table width = "100%">
<tbody>
<tr>
<td>
{% highlight cpp %}
#ifndef PROJ1_DIR1_DIR2_H
#define PROJ1_DIR1_DIR2_H
...
#endif // PROJ1_DIR1_DIR2_H
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#pragma once


...
{% endhighlight %}
</td>
</tr>
<tr>
<td>
Compatible with old compilers.<br>
More headers with the same content.<br>
Name your MACRO carefully (systematically).<br>
</td>
<td>
More efficient.<br>
Can be generated by Visual Studio.
</td>
</tr>
</tbody>
</table>

### 1.2 Self-contained
Clear your dependencies.

<table width = "100%">
<tbody>
<tr><td> A.h </td><td> B.h </td> <td> C.h </td> </tr>
<tr>
<td>
{% highlight cpp %}
#pragma once

class A {

    ...


};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#pragma once

#include "A.h"
class B {
    ...
    A a;
    ...
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#pragma once

#include "A.h"	
#include "B.h"
class C {
    A a;
    B b;
};
{% endhighlight %}
</td>
</tr>
</tbody>
</table>

Also include A.h in C.h because it depends on A. Even if B.h has already included A.h. Do it rightly not just some way it works.

One may remove B from C later, or A from B. In the latter case, the change of B causes compile error of C, that's terrible in large projects.

### 1.3 Decoupling
Do not include unnecessary files.

#### Forward declaration

{% highlight cpp %}
class D;
class C {
    ...
    D *d;
    ...
};
{% endhighlight %}

> A pointer is merely a number unless you need to interpret it. Until then, you don't need to know what the class looks like.

#### Hide implementations

<table width = "100%">
<tbody>
<tr><td> Solver.h </td><td> Solver.cpp </td> </tr>
<tr>
<td>
{% highlight cpp %}
#pragma once
#include "Input.h"
#include "Output.h"
class Solver {
    ...
    Output solve(Input input);
    ...
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#include "Solver.h"

#include <Eigen>
#include <GCO>
Output Solver::solve(Input input)
{
    ...
}
{% endhighlight %}
</td>
</tr>
</tbody>
</table>

## 2. Classes

### 2.1 RAII

Resource acquisition is initialization. (Uninitialized << Initialized << Default initialization).

All for one and one for all. __Copy Constructor__, __Assignment operator__ and __Destructor__, use them all or none, none is better.

A default constructor will initialize all members with their default constructors. Think a way to take the advantage.

As long as the __resource__ means memory, the Three can be avoid. Think a way to use the default generated version. Use shared_ptr and vector.

> Any time you are coding something sound basic, think about STL, do not reinvent the wheel, life is short after all.

<table width = "100%">
<tbody>
<tr><td> Bad </td><td> Good </td> </tr>
<tr>
<td>
{% highlight cpp %}
...
class A;
class B
{
public:
    B(int size);
    B(const B &b);
    ~B();
    
    B operator=(const B &b);
private:
    A *m_a;
    A *m_as;
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
...
class A;
class B
{
public:
    B(int size);
    
    
    
    
private:
    std::shared_ptr<A> m_a;
    std::vector<A> m_as;
};
{% endhighlight %}
</td>
</tr>
<tr>
<td>
{% highlight cpp %}
B::B(int size)
    :m_a(new A)
    ,m_as(new A[size])
{
}

B::B(const B &b)
    :m_a(b.ma)
    ,m_as(new A[size])
{
    ...
}

B operator=(const B &b)
{
    if (b == *this) return *this;
    m_a = b.m_a;
    //... what a mess
}

B::~B()
{
    delete m_a;
    delete[] m_as;
}


{% endhighlight %}
</td>
<td>
{% highlight cpp %}
B::B(int size)
    :m_a(new A)
    ,m_as(size)
{
}





// The Three are unnecessary now.
// Less code, less bugs.












...
{% endhighlight %}
</td>
</tr>
</tbody>
</table>

### 2.2 Use initialization list
<table width = "100%">
<tbody>
<tr>
<td>
{% highlight cpp %}
class A
{
public:
    A(int size);
   
private:
    int m_number;
    vector<int> m_numbers;
};
{% endhighlight %}
</td>

<td>
{% highlight cpp %}
A::A(int size)
    :m_number(0)
    ,m_numbers(size)
{
    
    
    ...
    
    
}
{% endhighlight %}
</td>
</tr>
</tbody>
</table>

### 2.3 Use inheritance carefully

Inheritance is a big thing. Think before using it. 
Composition(has-a) is often more appropriate than inheritance(is-a).

Make the dependency as local as possible.

<table width = "100%">
<tbody>
<tr>
<td> Local instance </td>
<td> A member of pointer </td>
<td> A member of instance </td>
<td> Inheritance </td>
</tr>
<tr>
<td>
{% highlight cpp %}
void B::method1()
{
    A a;
    ...
}
void B::method2(A &a)
{
    ...
}
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
class A;

class B
{
    ...
    
private:
    A *m_pa;
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#include "A.h"

class B
{
    ...
    
private:
    A m_a;
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#include "A.h"

class B : public A
{

    ...


};
{% endhighlight %}
</td>
</tr>
<tr>
<td> Include A.h in B.cpp </td>
<td> Declare A in B.h <br>
	Include A.h in B.cpp </td>
<td> Include A.h in B.h </td>
<td> Include A.h in B.h <br>
Unless <br>
B::someMethodOfA() <br>
is needed
</td>
</tr>
</tbody>
</table>

> Polymorphism is an overestimated feature in C++.

### 2.3 struct or class
<table width = "100%">
<tbody>
<tr>
<td>
struct
</td>
<td>
class
</td>
</tr>

<tr>

<td>
{% highlight cpp %}
struct A
{


    int member1;
    
    
};
{% endhighlight %}
</td>

<td>
{% highlight cpp %}
class A
{
public:
    int GetMember1() const;
    
private:
    int m_member1;
};
{% endhighlight %}
</td>

</tr>

<tr>
<td>
For pure data structure. <br>
No methods, inheritance. <br>
Compatible with C style.
</td>

<td>
When in class, do as classes do. <br>
Declare members as private. <br>
Use accessor if necessary. <br>
Add a prefix to the member name.

</td>

</tr>
</tbody>
</table>


## 3. Function

### 3.1 Operator Overloading

Never use it. Use function instead. Unless you have higher aesthetic ambitions and are not persuaded by the following:

1. +,-,*,/ makes implication that the operator is efficient and bug free.
2. Undistinguishable from build-in operators, hard to find.
3. 


