---
layout: post
tags: c++ 
categories: code

---

# 1. Header

<table width = "100%">
<tbody>
<tr><td> .h </td><td> .cpp </td> </tr>
<tr>
<td>
What can I do?<br>
</td>
<td>
How to do it?<br>
</td>
</tr>
<tr>
<td>
Precompile (Expanded to text.)
</td>
<td>
Compile (to Binary, .obj in VC.)
</td>
</tr>
<tr>
<td>
Affect all files include it. <br>
Be more careful.<br>
</td>
<td>
Local.
</td>
</tr>
</tbody>
</table>

### 1.1 #pragma once
To prevent multiple inclusion.

<table width = "100%">
<tbody>
<tr>
<td>
{% highlight cpp %}
#ifndef FOO_BAR_BAZ_H
#define FOO_BAR_BAZ_H
...
#endif // FOO_BAR_BAZ_H
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#pragma once


...
{% endhighlight %}
</td>
</tr>
<tr>
<td>
Compatible with old compilers.<br>
More headers with the same content.<br>
Name your MACRO carefully (systematically).<br>
</td>
<td>
More efficient.<br>
Can be generated by Visual Studio.
</td>
</tr>
</tbody>
</table>

### 1.2 Self-contained
Clear your dependencies.

<table width = "100%">
<tbody>
<tr><td> A.h </td><td> B.h </td> <td> C.h </td> </tr>
<tr>
<td>
{% highlight cpp %}
#pragma once

struct A {

    ...


};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#pragma once

#include "A.h"
struct B {
    ...
    A a;
    ...
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#pragma once

#include "A.h"	
#include "B.h"
struct C {
    A a;
    B b;
};
{% endhighlight %}
</td>
</tr>
</tbody>
</table>

Also include A.h in C.h because it depends on A. Even if B.h has already included A.h. Do it rightly not just some way it works.
One may remove B from C, or A from B. In the latter case, the change of B causes compile error of C, that's terrible in large projects.

### 1.3 Decoupling
Do not include unnecessary files.

#### Forward declaration

{% highlight cpp %}
class D;
struct C {
    ...
    D *d;
    ...
};
{% endhighlight %}

> A pointer is merely a number unless you need to interpret it. Until then, you don't need to know what the class D looks like.

#### Hide implementations

<table width = "100%">
<tbody>
<tr><td> Solver.h </td><td> Solver.cpp </td> </tr>
<tr>
<td>
{% highlight cpp %}
#pragma once
#include "Input.h"
#include "Output.h"
struct Solver {
    ...
    Output solve(Input input);
    ...
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
#pragma once
#include "Solver.h"
#include <Eigen>
#include <GCO>
Output Solver::solve(Input input)
{
    ...
}
{% endhighlight %}
</td>
</tr>
</tbody>
</table>

# 2. Classes

### 2.1 RAII

Resource acquisition is initialization. (Uninitialized << Initialized << Default initialization).

All for one and one for all. __Copy Constructor__, __Assignment operator__ and __Destructor__, use them all or none, none is better.

A default constructor will initialize all members with their default constructors. Think a way to take the advantage.

As long as the __resource__ means memory, the Three can be avoid. Think a way to use the default generated version. Use shared_ptr and vector.

<table width = "100%">
<tbody>
<tr><td> Bad </td><td> Good </td> </tr>
<tr>
<td>
{% highlight cpp %}
...
class A;
class B
{
public:
    B(int size);
    B(const B &b);
    ~B();
    
    B operator=(const B &b);
private:
    A *m_a;
    A *m_as;
};
{% endhighlight %}
</td>
<td>
{% highlight cpp %}
...
class A;
class B
{
public:
    B(int size);
    
    
    
    
private:
    std::shared_ptr<A> m_a;
    std::vector<A> m_as;
};
{% endhighlight %}
</td>
</tr>
<tr>
<td>
{% highlight cpp %}
B::B(int size)
    :m_a(new A)
    ,m_as(new A[size])
{
}

B::B(const B &b)
    :m_a(b.ma)
    ,m_as(new A[size])
{
    ...
}

B operator=(const B &b)
{
    if (b == *this) return *this;
    m_a = b.m_a;
    //... what a mess
}

B::~B()
{
    delete m_a;
    delete[] m_as;
}


{% endhighlight %}
</td>
<td>
{% highlight cpp %}
B::B(int size)
    :m_a(new A)
    ,m_as(size)
{
}





// The Three are unnecessary now.
// Less code, less bugs.












...
{% endhighlight %}
</td>
</tr>
</tbody>
</table>

